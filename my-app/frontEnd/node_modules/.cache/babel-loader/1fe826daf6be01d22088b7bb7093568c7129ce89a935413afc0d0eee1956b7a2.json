{"ast":null,"code":"export const isValidSudoku = grid => {\n  const size = grid.length; // Dynamisk bestem størrelsen af brættet\n  const boxSize = Math.sqrt(size); // Beregn størrelsen af en enkelt box\n  let newValidity = Array(size).fill().map(() => Array(size).fill(true));\n  let isValid = true;\n  let firstOccurrencesRows = Array(size).fill().map(() => ({}));\n  let firstOccurrencesCols = Array(size).fill().map(() => ({}));\n  let firstOccurrencesBoxes = Array(size).fill().map(() => ({}));\n  for (let i = 0; i < size; i++) {\n    for (let j = 0; j < size; j++) {\n      const val = grid[i][j];\n      if (val) {\n        // Check rows\n        if (val in firstOccurrencesRows[i]) {\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesRows[i][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesRows[i][val] = [i, j];\n        }\n\n        // Check columns\n        if (val in firstOccurrencesCols[j]) {\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesCols[j][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesCols[j][val] = [i, j];\n        }\n\n        // Calculate box index\n        const boxIndex = boxSize * Math.floor(i / boxSize) + Math.floor(j / boxSize);\n        // Check boxes\n        if (val in firstOccurrencesBoxes[boxIndex]) {\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesBoxes[boxIndex][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesBoxes[boxIndex][val] = [i, j];\n        }\n      }\n    }\n  }\n\n  // Check if any cell is marked as invalid\n  for (let row of newValidity) {\n    if (row.includes(false)) {\n      isValid = false;\n      break;\n    }\n  }\n  return {\n    isValid,\n    newValidity\n  };\n};","map":{"version":3,"names":["isValidSudoku","grid","size","length","boxSize","Math","sqrt","newValidity","Array","fill","map","isValid","firstOccurrencesRows","firstOccurrencesCols","firstOccurrencesBoxes","i","j","val","originalPos","boxIndex","floor","row","includes"],"sources":["C:/Users/marti/OneDrive/Skrivebord/Fagprojekt/Fagprojekt-/my-app/frontEnd/src/sudokuUtils.js"],"sourcesContent":["export const isValidSudoku = (grid) => {\r\n  const size = grid.length; // Dynamisk bestem størrelsen af brættet\r\n  const boxSize = Math.sqrt(size); // Beregn størrelsen af en enkelt box\r\n  let newValidity = Array(size).fill().map(() => Array(size).fill(true));\r\n  let isValid = true;\r\n\r\n  let firstOccurrencesRows = Array(size).fill().map(() => ({}));\r\n  let firstOccurrencesCols = Array(size).fill().map(() => ({}));\r\n  let firstOccurrencesBoxes = Array(size).fill().map(() => ({}));\r\n\r\n  for (let i = 0; i < size; i++) {\r\n      for (let j = 0; j < size; j++) {\r\n          const val = grid[i][j];\r\n          if (val) {\r\n              // Check rows\r\n              if (val in firstOccurrencesRows[i]) {\r\n                  newValidity[i][j] = false;\r\n                  const originalPos = firstOccurrencesRows[i][val];\r\n                  newValidity[originalPos[0]][originalPos[1]] = false;\r\n              } else {\r\n                  firstOccurrencesRows[i][val] = [i, j];\r\n              }\r\n\r\n              // Check columns\r\n              if (val in firstOccurrencesCols[j]) {\r\n                  newValidity[i][j] = false;\r\n                  const originalPos = firstOccurrencesCols[j][val];\r\n                  newValidity[originalPos[0]][originalPos[1]] = false;\r\n              } else {\r\n                  firstOccurrencesCols[j][val] = [i, j];\r\n              }\r\n\r\n              // Calculate box index\r\n              const boxIndex = boxSize * Math.floor(i / boxSize) + Math.floor(j / boxSize);\r\n              // Check boxes\r\n              if (val in firstOccurrencesBoxes[boxIndex]) {\r\n                  newValidity[i][j] = false;\r\n                  const originalPos = firstOccurrencesBoxes[boxIndex][val];\r\n                  newValidity[originalPos[0]][originalPos[1]] = false;\r\n              } else {\r\n                  firstOccurrencesBoxes[boxIndex][val] = [i, j];\r\n              }\r\n          }\r\n      }\r\n  }\r\n\r\n  // Check if any cell is marked as invalid\r\n  for (let row of newValidity) {\r\n      if (row.includes(false)) {\r\n          isValid = false;\r\n          break;\r\n      }\r\n  }\r\n\r\n  return { isValid, newValidity };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
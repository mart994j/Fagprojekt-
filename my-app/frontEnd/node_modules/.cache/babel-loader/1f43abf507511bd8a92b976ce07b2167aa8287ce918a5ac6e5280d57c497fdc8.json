{"ast":null,"code":"const [grid, setGrid] = useState([]);\nconst [validity, setValidity] = useState(Array(9).fill().map(() => Array(9).fill(true)));\nconst [isDataLoaded, setIsDataLoaded] = useState(false);\nconst [editableCells, setEditableCells] = useState([]);\nconst [userEdits, setUserEdits] = useState(Array(9).fill().map(() => Array(9).fill(false)));\nconst [timer, setTimer] = useState(0);\nconst [isTimerActive, setIsTimerActive] = useState(false);\nexport const fetchNewBoard = () => {\n  // Starter med at anmode om et nyt Sudoku-board fra serveren.\n  fetch('http://localhost:3000/generate').then(response => response.json()).then(data => {\n    // Opdaterer spillets grid med det nye board hentet fra serveren.\n    setGrid(data.board);\n\n    // Initialiserer editableCells baseret på, hvorvidt cellens værdi er 0.\n    // En celle er redigerbar, hvis dens værdi er 0 (tom).\n    const editable = data.board.map(row => row.map(value => value === 0));\n    setEditableCells(editable);\n\n    // Nulstiller userEdits til at markere alle celler som ikke-redigeret.\n    // Dette er nødvendigt for at fjerne visuelle indikationer af brugerindtastninger fra det forrige spil.\n    setUserEdits(Array(9).fill().map(() => Array(9).fill(false)));\n\n    // Nulstiller validity til at markere alle celler som gyldige.\n    // Dette sikrer, at ingen celler er markeret som ugyldige ved start af det nye spil.\n    setValidity(Array(9).fill().map(() => Array(9).fill(true)));\n\n    // Markerer at data er blevet indlæst og spillet er klar til at starte.\n    setIsDataLoaded(true);\n\n    // Nulstiller og starter timeren for det nye spil.\n    setTimer(0);\n    setIsTimerActive(true);\n  }).catch(error => {\n    // Logger fejlen til konsollen i tilfælde af en fejl under datahentning.\n    console.error('Error fetching data: ', error);\n  });\n};","map":{"version":3,"names":["grid","setGrid","useState","validity","setValidity","Array","fill","map","isDataLoaded","setIsDataLoaded","editableCells","setEditableCells","userEdits","setUserEdits","timer","setTimer","isTimerActive","setIsTimerActive","fetchNewBoard","fetch","then","response","json","data","board","editable","row","value","catch","error","console"],"sources":["C:/Users/marti/OneDrive/Skrivebord/Fagprojekt/Fagprojekt-/my-app/frontEnd/src/fetchNewBoard.js"],"sourcesContent":["const [grid, setGrid] = useState([]);\r\nconst [validity, setValidity] = useState(Array(9).fill().map(() => Array(9).fill(true)));\r\nconst [isDataLoaded, setIsDataLoaded] = useState(false);\r\nconst [editableCells, setEditableCells] = useState([]);\r\nconst [userEdits, setUserEdits] = useState(Array(9).fill().map(() => Array(9).fill(false)));\r\nconst [timer, setTimer] = useState(0);\r\nconst [isTimerActive, setIsTimerActive] = useState(false);\r\n\r\nexport const fetchNewBoard = () => {\r\n    // Starter med at anmode om et nyt Sudoku-board fra serveren.\r\n    fetch('http://localhost:3000/generate')\r\n      .then(response => response.json())\r\n      .then(data => {\r\n        // Opdaterer spillets grid med det nye board hentet fra serveren.\r\n        setGrid(data.board);\r\n  \r\n        // Initialiserer editableCells baseret på, hvorvidt cellens værdi er 0.\r\n        // En celle er redigerbar, hvis dens værdi er 0 (tom).\r\n        const editable = data.board.map(row => row.map(value => value === 0));\r\n        setEditableCells(editable);\r\n  \r\n        // Nulstiller userEdits til at markere alle celler som ikke-redigeret.\r\n        // Dette er nødvendigt for at fjerne visuelle indikationer af brugerindtastninger fra det forrige spil.\r\n        setUserEdits(Array(9).fill().map(() => Array(9).fill(false)));\r\n  \r\n        // Nulstiller validity til at markere alle celler som gyldige.\r\n        // Dette sikrer, at ingen celler er markeret som ugyldige ved start af det nye spil.\r\n        setValidity(Array(9).fill().map(() => Array(9).fill(true)));\r\n  \r\n        // Markerer at data er blevet indlæst og spillet er klar til at starte.\r\n        setIsDataLoaded(true);\r\n  \r\n        // Nulstiller og starter timeren for det nye spil.\r\n        setTimer(0);\r\n        setIsTimerActive(true);\r\n      })\r\n      .catch(error => {\r\n        // Logger fejlen til konsollen i tilfælde af en fejl under datahentning.\r\n        console.error('Error fetching data: ', error);\r\n      });\r\n  };\r\n  "],"mappings":"AAAA,MAAM,CAACA,IAAI,EAAEC,OAAO,CAAC,GAAGC,QAAQ,CAAC,EAAE,CAAC;AACpC,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGF,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AACxF,MAAM,CAACE,YAAY,EAAEC,eAAe,CAAC,GAAGP,QAAQ,CAAC,KAAK,CAAC;AACvD,MAAM,CAACQ,aAAa,EAAEC,gBAAgB,CAAC,GAAGT,QAAQ,CAAC,EAAE,CAAC;AACtD,MAAM,CAACU,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3F,MAAM,CAACQ,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAAC,CAAC,CAAC;AACrC,MAAM,CAACc,aAAa,EAAEC,gBAAgB,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;AAEzD,OAAO,MAAMgB,aAAa,GAAGA,CAAA,KAAM;EAC/B;EACAC,KAAK,CAAC,gCAAgC,CAAC,CACpCC,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC,CACjCF,IAAI,CAACG,IAAI,IAAI;IACZ;IACAtB,OAAO,CAACsB,IAAI,CAACC,KAAK,CAAC;;IAEnB;IACA;IACA,MAAMC,QAAQ,GAAGF,IAAI,CAACC,KAAK,CAACjB,GAAG,CAACmB,GAAG,IAAIA,GAAG,CAACnB,GAAG,CAACoB,KAAK,IAAIA,KAAK,KAAK,CAAC,CAAC,CAAC;IACrEhB,gBAAgB,CAACc,QAAQ,CAAC;;IAE1B;IACA;IACAZ,YAAY,CAACR,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;;IAE7D;IACA;IACAF,WAAW,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;;IAE3D;IACAG,eAAe,CAAC,IAAI,CAAC;;IAErB;IACAM,QAAQ,CAAC,CAAC,CAAC;IACXE,gBAAgB,CAAC,IAAI,CAAC;EACxB,CAAC,CAAC,CACDW,KAAK,CAACC,KAAK,IAAI;IACd;IACAC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;EAC/C,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}
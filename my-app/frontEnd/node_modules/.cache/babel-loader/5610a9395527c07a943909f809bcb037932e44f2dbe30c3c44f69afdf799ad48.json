{"ast":null,"code":"export const isValidSudoku = grid => {\n  let newValidity = Array(9).fill().map(() => Array(9).fill(true));\n  let isValid = true;\n\n  // Track first occurrences of values in rows, columns, and boxes\n  let firstOccurrencesRows = Array(9).fill().map(() => ({}));\n  let firstOccurrencesCols = Array(9).fill().map(() => ({}));\n  let firstOccurrencesBoxes = Array(9).fill().map(() => ({}));\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      const val = grid[i][j];\n      if (val) {\n        // Check rows\n        if (val in firstOccurrencesRows[i]) {\n          // Mark both the original and the duplicate as invalid\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesRows[i][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesRows[i][val] = [i, j];\n        }\n\n        // Check columns\n        if (val in firstOccurrencesCols[j]) {\n          // Mark both the original and the duplicate as invalid\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesCols[j][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesCols[j][val] = [i, j];\n        }\n\n        // Calculate box index\n        const boxIndex = 3 * Math.floor(i / 3) + Math.floor(j / 3);\n        // Check boxes\n        if (val in firstOccurrencesBoxes[boxIndex]) {\n          // Mark both the original and the duplicate as invalid\n          newValidity[i][j] = false;\n          const originalPos = firstOccurrencesBoxes[boxIndex][val];\n          newValidity[originalPos[0]][originalPos[1]] = false;\n        } else {\n          firstOccurrencesBoxes[boxIndex][val] = [i, j];\n        }\n      }\n    }\n  }\n\n  // Check if any cell is marked as invalid\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      if (!newValidity[i][j]) {\n        isValid = false;\n        break;\n      }\n    }\n    if (!isValid) break;\n  }\n  return {\n    isValid,\n    newValidity\n  };\n};","map":{"version":3,"names":["isValidSudoku","grid","newValidity","Array","fill","map","isValid","firstOccurrencesRows","firstOccurrencesCols","firstOccurrencesBoxes","i","j","val","originalPos","boxIndex","Math","floor"],"sources":["/Users/sebastianwulf-andersen/Documents/Fagprojekt-/my-app/frontEnd/src/sudokuUtils.js"],"sourcesContent":["\n\nexport const isValidSudoku = (grid) => {\n    let newValidity = Array(9).fill().map(() => Array(9).fill(true)); \n    let isValid = true;\n  \n    // Track first occurrences of values in rows, columns, and boxes\n    let firstOccurrencesRows = Array(9).fill().map(() => ({}));\n    let firstOccurrencesCols = Array(9).fill().map(() => ({}));\n    let firstOccurrencesBoxes = Array(9).fill().map(() => ({}));\n  \n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        const val = grid[i][j];\n        if (val) {\n          // Check rows\n          if (val in firstOccurrencesRows[i]) {\n            // Mark both the original and the duplicate as invalid\n            newValidity[i][j] = false; \n            const originalPos = firstOccurrencesRows[i][val];\n            newValidity[originalPos[0]][originalPos[1]] = false; \n          } else {\n            firstOccurrencesRows[i][val] = [i, j]; \n          }\n  \n          // Check columns\n          if (val in firstOccurrencesCols[j]) {\n            // Mark both the original and the duplicate as invalid\n            newValidity[i][j] = false; \n            const originalPos = firstOccurrencesCols[j][val];\n            newValidity[originalPos[0]][originalPos[1]] = false; \n          } else {\n            firstOccurrencesCols[j][val] = [i, j]; \n          }\n  \n          // Calculate box index\n          const boxIndex = 3 * Math.floor(i / 3) + Math.floor(j / 3);\n          // Check boxes\n          if (val in firstOccurrencesBoxes[boxIndex]) {\n            // Mark both the original and the duplicate as invalid\n            newValidity[i][j] = false; \n            const originalPos = firstOccurrencesBoxes[boxIndex][val];\n            newValidity[originalPos[0]][originalPos[1]] = false; \n          } else {\n            firstOccurrencesBoxes[boxIndex][val] = [i, j]; \n          }\n        }\n      }\n    }\n  \n    // Check if any cell is marked as invalid\n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        if (!newValidity[i][j]) {\n          isValid = false;\n          break;\n        }\n      }\n      if (!isValid) break;\n    }\n\n    return { isValid, newValidity };\n  };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}